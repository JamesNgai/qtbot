import json
import random
import re
from datetime import datetime
from typing import Union, Tuple

import discord
from discord.ext import commands
from nltk.corpus import stopwords


class Comics:
    """A cog which allows you to fetch random / search for XKCD comics.

    Attributes
    ----------
    STOPWORDS : set
        A set of common stopwords which will be stripped from user input.

    COMICS : dict[str, dict]
        A full list of XKCD comics as of 1/9/2018 in json format from the API
        TODO:
        Create functions to update this file

    BLOB : dict[str, str]
        The keys are (for now) str representations of sets of the combined alt-text and safe-titles
        of any given comic. I will add transcriptions to this once I test its impact on performance
        since I think that will give better matches.

        The key is the str ID of the comic which is represented by the key.

    Note
    ----
    The "BLOB" file was generated by running the alt-text and safe-titles through an equivalent of the
    _process_text command below, which strips common words. The below command(s) test user searches
    based on the # of whole-word matches present in the keys of the blob file.
    """
    STOPWORDS = set(stopwords.words('english'))
    with open('data/xkcd_comics.json') as f:
        COMICS = json.load(f)
    with open('data/xkcd_blob.json') as f:
        BLOB = json.load(f)

    def __init__(self, bot):
        self.bot = bot
        self.session = bot.aio_session

    def _process_text(self, text: str) -> str:
        """A helper method to strip common words from text.

        Parameters
        ----------
        text : str
            Text to be processed.

        Returns
        -------
        str
            The stripped text.
        """
        stripped_set = set([re.sub('\W+', '', x) for x in text.lower().split()])
        return ' '.join(stripped_set - self.STOPWORDS)

    def _get_best_match(self, input: str) -> Union[Tuple[int, str], None]:
        """A helper method to retrieve a comic most similar to given input.

        Parameters
        ----------
        input : str
            User query for a comic.

        Returns
        -------
        Union[Tuple[int, str], None]
           (number_of_matches, str id of comic)
           Returns None if there were no hits whatsoever.
        """
        match_list = []
        input_set = set(input.lower().split())
        for key in self.BLOB:
            # Union of the two sets to determine # of whole word matches.
            strength = len(set(key.split()) & input_set)
            match_list.append((strength, self.BLOB[key]))

        # Sort the match list based on # of matches and select the first result.
        best_match = sorted(match_list, key=lambda x: x[0], reverse=True)[0]
        if best_match[0] == 0:
            # If None, _comic_to_embed will select a random comic
            return None

        return best_match

    def _comic_to_embed(self, id_tup: Union[Tuple, None]) -> discord.Embed:
        """A helper method to convert an xkcd comic to an embed.

        Parameters
        ----------
        id_tup : tuple
            The tuple returned by the _get_best_match method.
            Can also be none to return a random comic

        Returns
        -------
        discord.Embed
        """
        # Determines whether to grab a random comic.
        if id_tup is None:
            comic = self.COMICS[random.choice(list(self.COMICS))]
        else:
            comic = self.COMICS[id_tup[1]]

        # Creates the embed
        em = discord.Embed()
        em.title = comic['safe_title']
        # Some random icon I found
        em.set_author(name='XKCD', icon_url='https://cdn.shopify.com/s/files/1/0149/3544/products/'
                                            'hoodie_1_7f9223f9-6933-47c6-9af5-d06b8227774a_1024x1024.png?v=1479786341')
        em.set_image(url=comic['img'])
        # Some responses don't contain links
        # Thanks xkcd
        em.url = comic['link'] or f'https://xkcd.com/{comic["num"]}/'
        # Determines what kind of footer to display
        em.set_footer(text='Random comic' if id_tup is None else f'Matched with {id_tup[0]} hit(s)')
        em.timestamp = datetime(int(comic['year']),
                                int(comic['month']),
                                int(comic['day']))

        return em

    @commands.command(aliases=['xk'])
    async def xkcd(self, ctx, *, query: str = None):
        """Search for an xkcd, or get a random one"""
        if query is None:
            return await ctx.send(embed=self._comic_to_embed(None))

        stripped_query = self._process_text(query)
        best_match = self._get_best_match(stripped_query)

        return await ctx.send(embed=self._comic_to_embed(best_match))


def setup(bot):
    bot.add_cog(Comics(bot))
